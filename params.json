{"name":"FsRandom","tagline":"A random number generator framework designed for F#","body":"FsRandom\r\n========\r\n\r\nFsRandom (formerly RecycleBin.Random) is a (purely-functional) random number generator framework designed for F# language.\r\nIt helps you to obtain a variety of random numbers to use more than ten predefined generators,\r\nand to define a new function to generate random numbers you want.\r\n\r\nRandoms Functions\r\n-----------------\r\n\r\n* **RandomNumberGenerator module** provides standard random number generators: <code>\\`\\`(0, 1)\\`\\`</code>, <code>\\`\\`[0, 1)\\`\\`</code>, <code>\\`\\`(0, 1]\\`\\`</code>, and <code>\\`\\`[0, 1]\\`\\`</code>.\r\n* **Random module** manipulates random numbers.\r\n* **Statistics module** provides a variety of statistical distributions such like `uniform`, `normal` and `gamma`.\r\n* **Seq module** provides functions for generating random number sequences.\r\n* **Array module** provides functions for array operations like `shuffle`.\r\n* **Utility module** provides utility functions.\r\n\r\nAlso, user-defined functions can be implemented easily (see below).\r\n\r\nHow to Install\r\n--------------\r\n\r\n### Install from NuGet\r\n\r\nFsRandom is [available on the NuGet Gallery](https://nuget.org/packages/FsRandom/).\r\nUse the following command to install FsRandom via NuGet.\r\n\r\n```\r\nInstall-Package FsRandom\r\n```\r\n\r\n[Visit the site](https://nuget.org/) for more information.\r\n\r\n### Build from source code\r\n\r\nRun:\r\n\r\n```\r\nfsi tools\\build.fsx --debug\r\n```\r\n\r\nHow to Use\r\n----------\r\n\r\n### First random number\r\n\r\nLet's try to get a first random number `z` ~ N(0, 1).\r\nIt is easy to do with `normal` random number generator in the Statistics module.\r\nTo give the specific parameter, say the mean of 0 and the variance of 1, do:\r\n\r\n```fsharp\r\nlet generator = Statistics.normal (0.0, 1.0)\r\n```\r\n\r\nThe generator function is only able to use with a pseudo-random number generator (PRNG).\r\nThe PRNG constructs a computation expression to generate random numbers.\r\nThe computation expression is a function which takes a random seed and returns a random number and a new seed for the next call.\r\nIt is important to keep the new state because it is used when we generate a new random number.\r\n\r\nHere for example, we choose xorshift PRNG, which is implemented in FsRandom.\r\nWe need to define an initial random seed first for xorshift algorithm\r\n(of course, another algorithm is available rather than xorshift, as described later).\r\nIt is a tuple composed of four 32-bit unsigned integers.\r\nAnd then, we should combine the PRNG and the seed using `createState` function.\r\n\r\n```fsharp\r\nlet seed = 123456789u, 362436069u, 521288629u, 88675123u\r\nlet state = createState xorshift seed\r\n```\r\n\r\nNow we can retrieve a random number using `Random.get` function.\r\n\r\n```\r\nlet z = Random.get generator state\r\nprintfn \"%f\" z\r\n```\r\n\r\nSince `Random.get` returns a stateless function,\r\nif you do the code above, the same thing occurs.\r\nTo generate a new random number,\r\nwe need to get next state using `Random.next` instead of `Random.get`:\r\n\r\n```fsharp\r\nlet _, nextState = Random.next generator state\r\nlet z2 = Random.get generator nextState\r\nprintfn \"%f\" z2\r\n```\r\n\r\n### Transforming random numbers\r\n\r\nTransformation of random numbers is a regular work.\r\nFsRandom defines `Random.transformBy` function for the purpose.\r\nThe following code shows how to use it.\r\n\r\n```fsharp\r\nlet plusOne x = x + 1.0\r\nRandom.transformBy plusOne <| Statistics.uniform (0.0, 1.0)\r\n|> Random.get\r\n<| state\r\n```\r\n\r\n`plusOne` is a function that takes an argument and adds one to it.\r\n`uniform` is a uniform random number generator between its two arguments.\r\nSo `x` finally becomes a uniform random number between 1 and 2.\r\n\r\nThe both following codes return the same results as above.\r\n\r\n``` fsharp\r\nRandom.identity <| Statistics.uniform (0.0, 1.0)\r\n|> Random.get\r\n<| state\r\n|> plusOne\r\n```\r\n\r\n```fsharp\r\nStatistics.uniform (0.0, 1.0)\r\n|> Random.get\r\n<| state\r\n|> plusOne\r\n```\r\n\r\n### Random number sequence\r\n\r\nUsually, we use a lot of random numbers for our needs.\r\nThe following code defines a function generating an infinite binary sequence\r\nusing Bernoulli random number generator,\r\nand it illustrates how we can generate a number of random numbers.\r\n\r\n```fsharp\r\nlet rec binaries initialState = seq {\r\n   let binary, nextState = Random.next (Statistics.bernoulli 0.5) initialState\r\n   yield binary\r\n   yield! binaries nextState // recursively generating binaries.\r\n}\r\n```\r\n\r\nOr, more precisely like the following:\r\n\r\n```fsharp\r\nlet binaries state = Seq.ofRandom (Statistics.bernoulli<'a> 0.5) state\r\n```\r\n\r\n### Using `System.Random`\r\n\r\nThe examples above uses `xorshift` to generate random numbers.\r\nThe familliar `System.Random` (and its subclasses) is available in the workflow.\r\nJust use `systemrandom` instead of `xorshift`.\r\n\r\n```fsharp\r\nlet r0 = System.Random ()\r\nlet s = createState systemrandom r0\r\n```\r\n\r\nBecause `System.Random` is a stateful object,\r\nunlike `xorshift`, we will get different result on each call.\r\n\r\n```fsharp\r\nlet u1 = Random.get generator s\r\nlet u2 = Random.get generator s\r\n```\r\n\r\n### Constructing a user-defined random number generator\r\n\r\n#### Computation expression\r\n\r\nThis section explains how to construct random computation expressions such as `xorshift` and `systemrandom`.\r\n\r\nFsRandom has a random computation expression builder named `random`,\r\nwhich enables users to construct a user-defined random computation expression builder.\r\nThe `random` uses a pseudorandom number generating function, that is, a function\r\nwhich has a type of `Prng<'s> = 's -> uint64 * 's` where `'s` is a type of state seed.\r\n`Prng` is an actual random number generator which receives a random seed (`: 's`) and returns\r\na random number in 64-bit resolution (`: uint64`) and a next state (`: 's`) in the random computation expression.\r\nAs we saw above, FsRandom currently supports xorshift algorithm and `System.Random`.\r\n\r\nAs an example of user-defined `Prng`,\r\nlet's implement [linear congruential generator](http://en.wikipedia.org/wiki/Linear_congruential_generator).\r\nFirst, we make a function of `Prng`.\r\n\r\n```fsharp\r\n// Coefficients are cited from Wikipedi\r\nlet linear x = x, 6364136223846793005uL * x + 1442695040888963407uL\r\n```\r\n\r\nThe first returned value is a random number and the second returned value is a next state.\r\nNote that modulus is not defined because `Prng` is required to return random numbers\r\nin 64-bit resolution.\r\n\r\nHereafter we can use the `linear` builder to generate random numbers.\r\n\r\n```fsharp\r\nlet linearState = createState linear 0x123456789ABCDEFuL\r\nRandom.get generator linearState\r\n```\r\n\r\n#### Generator function\r\n\r\nThis section explains how to construct generator functions such like `normal` and `uniform`.\r\n\r\nThe type of generator function is `GeneratorFunction<'a>`,\r\nwhere `'a` is a type of random number.\r\n\r\nAs an example of user-defined generator function,\r\nlet's construct a random number generator to produce an *approximate*\r\nstandard normal random number (approximately ~ N(0, 1)).\r\nTheorem says that the mean of 12 standard random numbers,\r\nnamely, 12 random numbers between 0 and 1, approximates a normal random number\r\nwith mean of 1/2 and variance of 1/12.\r\nTherefore, if we subtract 6 from the sum of 12 standard random numbers, the result\r\napproximates a standard normal random number.\r\n\r\n```fsharp\r\nlet approximatelyStandardNormal = random {\r\n   let! values = Array.randomCreate 12 ``(0, 1)``  // ``(0, 1)`` is a standard random number generator in (0, 1)\r\n   return Array.sum values - 6.0\r\n}\r\n```\r\n\r\nThe `approximatelyStandardNormal` can be used in the generating process as the following.\r\n\r\n```fsharp\r\nRandom.get approximatelyStandardNormal state\r\n```\r\n\r\nDon't forget that FsRandom has a normal random number generator `normal`.\r\n\r\nNumerical Examples\r\n------------------\r\n\r\n### Estimating pi, the ratio of a circle's circumference to its diameter.\r\n\r\n```fsharp\r\n// Generates random points on [-1, 1] x [-1, 1].\r\nlet randomPointGenerator = random {\r\n   let! x = Statistics.uniform (-1.0, 1.0)\r\n   let! y = Statistics.uniform (-1.0, 1.0)\r\n   return (x, y)\r\n}\r\n// Weight of a point\r\n// If the distance from (0, 0) is equal to or less than 1 (in the unit circle),\r\n// the weight is 4 (because random points are distributed on [-1, 1] x [-1, 1]).\r\nlet weight (x, y) = if x * x + y * y <= 1.0 then 4.0 else 0.0\r\n// Function to generate a sequence\r\nlet values = Seq.ofRandom (Random.transformBy weight randomPointGenerator)\r\n\r\n// Monte Carlo integration\r\n// Generates 1,000,000 random values and the average becomes estimator of pi\r\nvalues state\r\n|> Seq.take 1000000\r\n|> Seq.average\r\n|> printfn \"%f\"\r\n```\r\n\r\n### Generating bivariate normal random numbers using Gibbs sampler\r\n\r\nTo sample from bivariate normal distribution\r\n![n2](http://chart.apis.google.com/chart?cht=tx&chl=N_{2}%5cleft%28%5cbegin{bmatrix}%5cmu_{X}%5c%5c%5cmu_{Y}%5cend{bmatrix},%5c,%5cbegin{bmatrix}%5csigma_{X}^{2}%26%5csigma_{XY}%5c%5c%5csigma_{XY}%26%5csigma_{Y}^{2}%5cend{bmatrix}%5cright%29),\r\nwe will construct a Gibbs sample.\r\nBecause the density function f(x, y) is propotional to f(x | y) * f(y) and\r\nf(x | y) is propotinal to\r\n![p](http://chart.apis.google.com/chart?cht=tx&chl=p%5cleft%28%5cmu_{X}%2b%5cfrac{%5csigma_{XY}}{%5csigma_{Y}^{2}}%28y-%5cmu_{Y}%29,%5c,%5csigma_{X}^{2}-%5cfrac{%5csigma_{XY}^{2}}{%5csigma_{Y}^{2}}%5cright%29)\r\nwhere p is a univariate normal density function,\r\nthe Gibbs sampler for bivariate normal distribution consists of iterating as the following:\r\n\r\n1. Draw ![draw_x](http://chart.apis.google.com/chart?cht=tx&chl=x_{t%2b1}%5csim+N%5cleft%28%5cmu_{X}%2b%5cfrac{%5csigma_{XY}}{%5csigma_{Y}^{2}}%28y_{t}-%5cmu_{Y}%29,%5c,%5csigma_{X}^{2}-%5cfrac{%5csigma_{XY}^{2}}{%5csigma_{Y}^{2}}%5cright%29)\r\n2. Draw ![draw_y](http://chart.apis.google.com/chart?cht=tx&chl=y_{t%2b1}%5csim+N%5cleft%28%5cmu_{Y}%2b%5cfrac{%5csigma_{XY}}{%5csigma_{X}^{2}}%28x_{t%2b1}-%5cmu_{X}%29,%5c,%5csigma_{Y}^{2}-%5cfrac{%5csigma_{XY}^{2}}{%5csigma_{X}^{2}}%5cright%29)\r\n\r\nAnd it can be naturally translated into F# code as the following.\r\n\r\n```fsharp\r\nopen FsRandom.Statistics\r\nlet gibbsBinormal (meanX, meanY, varX, varY, cov) (_ : float, y : float) = random {\r\n   let! x' = normal (meanX + cov * (y - meanY) / varY, sqrt <| varX - cov ** 2.0 / varY)\r\n   let! y' = normal (meanY + cov * (x' - meanX) / varX, sqrt <| varY - cov ** 2.0 / varX)\r\n   return (x', y')\r\n}\r\nlet binormal parameter = Seq.markovChain (gibbsBinormal parameter)\r\n```\r\n\r\nNote that the generating bivariate normal random number sequence is [autocorrelated](http://en.wikipedia.org/wiki/Autocorrelation).\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}